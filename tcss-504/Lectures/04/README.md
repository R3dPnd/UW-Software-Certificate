Cool.
There we go.
and so yes, good afternoon to you my friends. And so second Saturday already in February. I'm starting to notice sun going down a little bit later like, Hey, you know, it's it's 5 30, and it's not pitch black. So
so I feel like we're winning there, you know, depending on where you're at. You might. You might have got dumped with a little bit of snow. I'm typically in my partner Holly's house. We got some here. My house in Tacoma doesn't, doesn't have near as much.
and we may, and we managed to mostly avoid the roads whenever there was any snow, and it just wasn't too bad for us. So hopefully, hopefully, things are okay on your end
as well.
Okay, well, so let me go to a screen share and take a look at
what we're about today. So
and so here's our, here's our agenda, which I posted under Module 5, which we'll take a look at. There's some things from Module 4 that we're we need to look at, and then module. 5. I act. I activated Module 6. Just so you can see what's coming. And in case you wanted to to, I don't know. Look ahead. Work ahead a little bit. On any of the material that that sits there.
So so I did post earlier today. Information about our 1st quits. So and so what I intend for the quiz and I'm gonna
go through the the study guide here in just a sec is it'll activate here on canvas or on canvas.
I'll set it up so that it activates Tuesday at 9 am.
And then, looking at the fact that that you guys are busy. I'm gonna leave it. Basically, it will be open from from Tuesday morning, 9 am. Ish.
until Friday, 1159 pm, so you can, you know, pick a spot in your in your schedule that fits you know, and maybe you want to wait to give yourself some time to study, and I do allow you to to build a cheat sheet or a cheat document. I don't care how big it is, and so you might want to put that together.
So. But but depending on what your schedule is, you know you could do it Tuesday, or you could wait and do it Friday, but providing some flexibility for you. So let me go over that
study guide.
Okay? And so
and so the the way the quizzes work. Very, very similar to what you saw in 5 0, 2 from veric
mostly because I wrote him originally, and so he, you know. He tweaked them a little bit, but but pretty much the same format there'll be at most 20 questions. Most of them tend to be true false, and then there's some multiple choice, and then there might be a
a single word, short answer, or 2.
But I like to keep them at single word when I do the short answer, because more than that is difficult, I like to set canvas. The quizzes up to auto grade so that you can get your results sooner as opposed to later. And so
yeah, it's it's it's formatted. Similarly to what you saw in 502.
I do permit you a cheat sheet, and, as I mentioned, it can be as big as you want. What I recommend that you do is that you take this study guide here, and then you just fill in the blanks as you deem necessary for your cheat sheet
and so you can grab from the slides you can grab from. You know anything that you want, because because I don't care how big it is. I don't care if you include diagrams. I don't care if you include source code you know, for stuff you've worked on. Any of those things. Not worried about it. So because and I and I think you know, you guys, you're all
you know, good students. To to be here and doing this. Me letting you build a a study guide or a cheat sheet.
You know it's just my way of getting you to study. So put together your your chat, your study guide. And then that's your resource for the quiz. So yeah.
And I don't make you turn the study guide in what I do request. And it's on our system here is that that is the only resource that you use. So please. You know no googling or chat gpting, or or whatever else. It's you and your your study guide or cheat sheet and and that's it. So
yeah. So there we go. So one of the things that I you know I usually talk about at the beginning of the quarter, but looking through the zooms, I'm not sure that I went over it formally. So so one of the things I'll ask you about is the software lifecycle. And and I have some slides on it. It's from module one. So we'll look at those in just a sec. I we might talk about agile manifesto. We haven't talked about it yet. So so this might get deleted.
yeah, I'm not sure we'll get to it. I'm gonna say, this agile manifesto won't
be on the quiz unless we get to it today, and I'm not sure we will. Because, as usual, we have an ambitious list of things.
We did talk about user stories and then use cases. We looked at use case diagram. Use case description. Some of you incorporated that into your Srs, so you should know what those 2 things are. We also talked about how to plan iterations. Using user stories, right? Assigning them points, figuring out how many points those points could be hours right? How many points of work you can get done for a for an iteration also known as a sprint and so you guys
are are on your 1st iteration. Right now it finishes up tomorrow, and then you'll turn in materials. And so that's part of what I want to talk to you about is is the set of deliverables that you have
and so you guys have done an Srs draft and so that was on my agenda to talk about. I can just mention real quickly. All 5 teams did an outstanding job on your Srs draft.
It's clear that you put good thought and good effort into it. You know, and I'll just be very upfront.
The reason that I am happy to give up a Saturday to work with with people like yourself is because you are hardworking. You're mature. You're dedicated, and for me, not not to talk down to my undergrad students. They try. But.
you guys, you did such. You did such a nice job on the Srs. And so, like every team got at least a little bit of extra points, because it was really that nice of an effort. And it was just a draft. And so and so you guys figured it out from the from the
lecture in this discussion, and the examples that we had, and I really think you've done a nice job of of setting yourself up for success on your projects because of the because of the work you put into your Srs. So you know, and so do know what an Srs contains. You know why it's important. And so we can talk about that right now. Of course, the Srs that contains the it's the who, what, where, when and why
of your software?
so requirements and specifications? You know, you got some requirements and specifications from me via the course project set of requirements and specifications, and obviously you borrowed some pieces from what I had to say. And then you added some things you know, specific to whatever project you chose, and the way you sought to implement it.
So so yeah, it's important to know it's the who, what, where, when, and why? Sometimes there can be some how how is is technically designed? But there's not, you know.
I don't know the Srs police or something. I guess that would be me. Sometimes you sneak some elements of design like if you put a Uml class diagram into your Srs, and it can make some sense to do that, you know. Technically, it's design, but it does help show
and describe the software as a whole. So same thing with a like a use case diagram with the little stick figure and the oval with the
active verb phrase, that is the use case. So
Srs, are those things I just mentioned. The Srs is a roadmap
to your software. We also talked about the fact that it's a living document, so it will be updated. It gets it changes as you work through your sprints or iterations. You know, as you discover more things inevitably, you'll forget some stuff or things that you thought at 1 point in time you'll recognize. Well, it's not quite that way, or we don't need it quite that way. So you update your Srs accordingly. It's just it's not a big deal.
The other thing about the Srs is it's a communication piece between team members between anyone else. Really, that has interest in the project for the most part right. An Srs is a lay person, so a non-developer can read and understand most of it. So it very much is a communication piece. It's also nice if you have a new team member coming on board, they can look at the Srs and and get themselves up to speed on.
Well, the who, what, where, when, and why of the software in a in a fairly short amount of time.
So so yes, you could be asked a question or 2 about an Srs, so you're working on, and you're you're finishing up. Your uml class diagram.
For your for your project. And I do want to talk a little bit about that check in with you guys and and see if you have any questions or clarifications about that. It is a draft. It's not going to be perfect. You're not going to think of everything. It is also a living document, and will evolve. But what I could ask you about on the quiz. Make sure you understand the symbols. So we talked about.
You know, the symbols for inheritance, the symbols for composition and aggregation. You know the one to many relationships how to represent those things?
And then also, of course, within a class rectangle. The the top part is the name of the class, the middle part? Are your your fields or your data, and then the bottom part? Are your behaviors also known as your methods or functions. So
just just the surface level stuff there that I talked about, because that's what you're working on. And so that's what I could hold you accountable for on the quiz. Remember, you get a cheat sheet or a cheat document. However, you want to describe that.
and so you can put in
pictures, you know, of the Uml stuff and the symbols. And oh, a plus is for public and a minus is for private and a pound sign, you know, or hashtag if you want to call it that
number sign that's for protected. So jot all that stuff down on your cheat sheet, and then that's your reference for the quiz, and so design patterns. You got a little bit of exposure to Mvc. In 502. We started. We talked some about it last week, and I do want to look at a little code example that I have posted under Module 4, and we'll talk a little bit about model view controller. Again.
key thing to know. Number one thing, the model view controller wants to do separate the model
from the view.
And the nice thing about that is that it allows for independent development.
which is quite important. Of course, in a team setting. The other thing that's important is that the model is isolated from everything else, and the model never wants to interact with the user. That is the purpose in life of the view.
So the view is for the user to see and interact with. We talked about that. I think you guys are pretty comfortable with it. The
the view could be console, based, right? You know, in python. Just doing some prints and reading stuff from the keyboard with the input function. You know, or you could do some some gui interface. So tk, enter
or or or whatever else you know, there's there's pie game. There's other toolkits as well.
But but the view is for the user to see interact with interact with. And the model that's our data, that's our business logic.
And then our controller, the code that goes in the controller right sits between the model and the view, and it more or less moves stuff back and forth between the model and the view as necessary. It's more or less the glue between those 2 things. So Controller code is also kind of the overseer for the software. It's going to well control the execution.
For those of you doing the dungeon adventure. You know your your controller code. That's Controller code is where your entry point to your program is. So this is where your
it's usually where your main function is.
So it starts everything up.
and then it's home base for all the major objects that are in your solution. So the major objects that are from the model. Maybe there's just one. And then from the view same thing.
and and and so the controller takes things that come from the view. So that's interaction with the user and then can pass that information on to the model. As necessary, you know it might it might. We talked about this last week. It might. Controller Code might call some method or function in the model to tell it to do something based on
some interaction the user had with the view and then it. And then the controller code could take the results of whatever the model did, and send those back to the view. And then the view could decide how to display that to the user, whether it's console, based or whether it's some kind of graphical user interface. But
model view controller is tried and true. Designed for Gui applications and web based applications which have a Gui component. We're not worried about the web based stuff here in 5 0, 4. But but there certainly is an application of Mvc, in that context. So
so the other thing that I want us to look at today, it's a really simple pattern mock object. We'll talk about it. Today I have a code example ready that makes it pretty clear what's going on. And actually, the code example. And of course, it's posted on canvas.
It utilizes sqlite, which? I will show you guys next week next week. I'll show you sqlite and pickling. So pickling is is how we can, how we can save things and and load things. Very well, quote easily. Easier than if you if you maybe didn't use this pickling so.
But that's for next week. And so we'll also take a look at. We're going to talk about the software lifecycle. But we'll also take a look at these solid principles. There's just 5 of them. Solid is an acronym. And so we'll take a look at those. These principles are good to have bouncing around in your brain as you build an object oriented solution. And that's what you're doing here for your project.
And then the other thing that I wanted to do, and we'll see this because I wanna talk some more about the observer pattern. So you guys got exposed to observer in 5 0. 2. You had the little lord of the rings and the eye of Sauron and the bad guys and so so I wanna I wanna revisit that and show you that solution and talk a little bit more about observer, but also point out that that
properties can be used as part of that observer pattern. It can be used as part of the model view controller, too. So a bunch of code examples to go along with basic lecture material this afternoon.
So these are the things that you can expect on your quiz, minus the agile manifesto unless we get to it. And then I'll say I mean it's not going to be on the quiz. You can be on the next quiz, but I don't know that we'll get to it today. So
so these are the different pieces that I'll ask you about no more than 2020 questions, you know. 15 ish, probably. And it's just to make sure you're following along with the things that we've been discussing. I don't use quizzes to try and show how much more clever I am than you any of those kinds of things. It's it's pretty straightforward stuff for the most part. So.
okay? And so, yeah, that'll activate. Tuesday. I'll post an announcement when the quiz is active, probably somewhere around 9 Am. Tuesday morning, and then you'll have through Friday
to get it done.
And so I do give you an hour.
If if for some reason you feel like that's not gonna be enough time for you. And and you might know from 5 0 2, and the quizzes that you had there reach out to me. It's easy for me to set up. I don't mind giving you a little more little bit more time, if you need it.
it's it's a little more difficult, not impossible. But for you guys, you know, University of Washington does have disability support services and if if you feel like you fall into that category in some way. You don't have to go through the formal process. Just reach out to me. And I I'm fine with with giving you some more time. If you have a lot of quiz anxiety and and that kind of stuff. So
yeah, there we go. So
that's the quiz to come right this coming week. Here's the content. These are the things to expect. You get a cheat sheet.
any questions, clarifications, some of the stuff we're gonna go over today. But
in terms of what's going on with the quiz.
feel free to drop something in the chat you can just unmute. You guys know me. I'm pretty casual.
Any questions, clarifications?
Okay?
All right.
I'm taking the silence as a positive thing. And yeah, we got that. We got nothing. Tom, let's move on.
Okay. Reach out to me if necessary. So there's a quiz.
Okay, so I already mentioned. So I did get through your Srs. And and truthfully, you guys did a great job, the only thing, and and just check your comments real quick for for some of you. The one thing that you do like to specify in your Srs is okay, you know, we're using python, but nailing down what version you're using?
Like at a minimum is good. If you say 3 dot 10 or 3 dot 12, or you know, whatever it is, that's good because
it's once again, it's it's a it's a useful tool. It's a communication tool. What happens if somebody new comes onto the Dev team, would it be nice for them to see? Oh, all right, you're using this version
a python, so I need to make sure, I got to update my machine so that I'm programming against that version of that compiler. And you know, also, you're gonna end up using sqlite.
We don't. We haven't talked about a version, but there is a sqlite module like I said, I will demonstrate next week. Hey? How do we plug in sqlite like from scratch
into a Pycharm project? And the good news is, it's really easy to do. Python has wonderful built-in support for sqlite, which is one of the reasons we're using it. And so we'll look at that.
So so yeah, good job on your Srs.
let me see, I was gonna mention one other thing. Oh, just a curiosity. So
so we got 5 different teams and
we got some dungeon adventure. 2.0 going on, and we have some file watcher going on.
and no one chose trivia mates. So it's fine with me. It is what it is, and I think some of you felt like, Oh, I just. I don't want to. I don't like games. I don't want to program games. And here's something that's not a game. And so I'm happy. But but also, like I explained, that file watcher is something that I worked on. It was a bit more involved than what I'm having. You guys do. But something I worked on in industry.
Once upon a time. So so yeah, I I thought it was pretty neat that you guys chose that. And for those of you that chose file watcher, there are a few other things I'm going to add to it.
which which is good for you. It's I'm not gonna overwhelm you, but but one of the things that I I will add is to have the ability to. Once you run a report.
basically do a search for okay, I want to find information about
files in this directory or whatever and so having the ability to send an email
through the program itself. Is an interesting thing. In the in the version that I worked on in industry. Goodness! Almost 20 years ago now. The version that I worked on
we connected to a server. So we opened up a socket. We had a we had. What's we? We had a service. We had a little program called a demon running behind the scenes, and
and so it would fire off it. I can't remember if it was we we said midnight at first, st but then we did like 2 in the morning, or something like that. So and it would just send data to a server. So
we'll do something kind of like that. But we'll say, Oh, let's let's do this email. And it's pretty easy to programmatically set up your software so that it can send an email. You have to have an email server. You have to have a set of credentials to connect to it. And you also have to like with Gmail
they've really nailed down the settings. To prevent people from spamming. You know, sending out mass emails and those kinds of things. And so so there's a few nuances to it. But but other. For the most part it's not hard to do, and it's kinda cool. So so that's something I know. I'll add. I haven't put it there yet. But but I'll add that so
okay, anyways, the other thing that you guys have going on. So 1st iteration, so your deliverables will be Tuesday, so remember that our iterations, also called sprints. Run will will always run
from Monday through Sunday, so you're on your 1st iteration. Now it finishes tomorrow, and I like to give you guys a couple of days to do your screenshots, you know. Talk to one another, pull your materials together, and so and so your deliverables will be the Tuesday following. An iteration, you know, when it completes
so so so yeah, I just just giving you a couple of couple of extra days to put stuff together. But I have open.
So
so yeah, you were to use you track to build your user stories or tasks or cards, whichever one you chose, you know, based on what I showed, or perhaps what you discovered, assign them points or hours. Right? Plan. Your 1st iteration. So you already did that, you know, set up a repository on Github
and then, of course, the other thing, I said, is anything project related you count hours for. And so you know, you worked on your Srs. That counts hours towards your project, and it's for your project you were, you know, if you worked on your uml class diagram, same thing anything related to the project at all. You just you log hours for, and you can write up
tasks or stories for those things. So you just need a single team member to turn these in. However, I will note that
each team member gets individual points. Now, you know, if everybody so so what I'm asking you to do is to try and get 7 h in, and then
that's the very minimum and I and I hope you can find a way to get to 9. But 7 gets you paid in full, and then if you want to get extra points or make up hours, you have to go beyond 9 and then you get extra points. So
And I forgot to delete the example.
so so what do you have to do? All right? Screenshots that show the stories or the tasks, and remember when we looked at you track and
well, I've got a timesheet open here. But
so
so there, there, or it's our agile board right? And so there's our open section, or in progress section, or or to verify and done. And so probably you can just do a screenshot of this to show. You know, the the stories or tasks that you created right and where they're at. And so I can't remember if I made this clear, you guys, but
I'm not worried at all. If, like you get done with your sprint or iteration, you know, tomorrow and stuff still in progress. You haven't gotten through it. That's fine with me. What I care about is body of work. And you're working on stuff, you know. Maybe you got everything done, it was in progress. You verified it, and remember
to verify, if at all possible, try and get with a team member to show. Hey? I was working on this. I think it's done, you know, kind of get them to sign off on it, but it also it's important to keep the lines of communication open. So your team member knows especially because they might be dependent on something you're doing. So.
So probably a screenshot of this suffices to show the stories you made. You know I can. You can also see the ones that are finished, the ones that are still in progress, and so that that really fits this
created 1st iteration and and completed stories. So one screenshot could show all of those and you know that's totally fine. And so then screenshots
from Github. Maybe you didn't have a whole lot going on yet. Totally fine. I'm not worried. Just pieces that show me body of work. And then I'm curious to see where you're at with things so screenshots. Show me what's in the repository. And then, just you know, what have you committed so far.
So.
and then an hours report. And so I just I had the hours report here. So I've got all these timesheets. You'll you'll just have, I think, one. But if I go to projects here.
Here's here's the 5 0 4 stuff that we did and so what you can do. And and this is has
slid over some days, and I gotta move. Zoom. Zoom's in my way.
Anyways gonna move zoom here also.
So one of the things that you can do, you know, it'll show you your total hours. Mine happens to be over here on the far side.
But what I found is is pretty easy to do is so note here, like on the 27th Monday, there's 5 h, and so if you click on this, it'll bring up all the work that you did on that day. And so the nice thing is is it shows you each of your entry, each of your entries right? And so here we can see
admin that was one of my accounts. 3 h, you know, setting up get, and you know, and then 1 h and 1 h doing these other things. And so if you did a screenshot of that, you know that that'll show you for a given day.
And then
you can go to the next one. And here's the next day. So so this gives me a breakdown very specifically of what you worked on. And so that's where I was saying. I want to know what you worked on. I don't care what you worked on. I just want to know what you worked on. And so if I can only see like just in this main report here, it just shows hours.
I did say to group by work type, you know, development and documentation, there's different views that are possible, you know. Here's author and the example I did. I have another account, Gmail. I didn't put any entries there. But it would show those
and and that's probably what you'll have, you know, on a team member by team member basis. But
if you open up for a given day, right? And so if you work for 7 days, or maybe you didn't work all 7 days or entries all 7 days. If you just click on these, it'll show you who it is that worked on them. And then what they did. So I'm just looking for body of work. You guys, I'm curious to see what it is you worked on
once again. Do I care that you finished a story or a task? No, do I hope you finish them? Yeah. But it's just body of work. And so you're showing me body of work I'm just. I'm not picky. Just try and make it so that I can see what you did
and and that's that's what I care about. So the you know shout, show hours for the team and gotta move zoom again. So breakdown like I just showed you so that I can see the specific things that you worked on. And you're trying for 7. That's your minimum
and so then, if you go beyond 9 every hour beyond 9 earns you a half a point extra, and I know some of you are already doing that, and I have to put a limit of 10 points extra total. So so yeah, if you were to put 29 h in, you could get 10 points extra credit. So so I limit it. There. You could go beyond that. But I'm only going to pay you 10 points, and it's been done before, right I've had. I've had students in the past that are very motivated. So
the points are out there for you to get if you want. And so the other thing that you'll turn in is a little readme dot txt that just talks about. You know any issues that you had? You know.
If you didn't have any issues, say, everything went fine. We feel like we got a good start. Just write that I'm gonna read through. I'm just curious as to to what you faced. You know, you might say. Well, we had some weirdness, just, you know, getting accustomed to you track and figuring out. You know how to enter the the timesheet hours, or whatever. I'm I'm just curious, like, I said, if everything went fine, just say, yeah, went fine. We we feel pretty good about where we're at starting off.
The the other thing, of course, is, if, as you're pulling things together, you're not sure. Please do reach out to me. It's easy to do a quick zoom
and look at stuff, and you can show me what you're doing, and you know we can probably figure it out
So that is part of my job. I do take it seriously. So reach out as necessary. And then, you know, if you have anything, maybe you've mocked it up. And I did see from looking at your your Srs that some of you had done little mock ups of a graphical user interface, you know, for I think I saw one for the file watcher. So if you have something.
you know in place and show it off. Yeah, I want to see it. I'm excited to see what you did. So do that.
and so what you're being asked to do here for this 1st iteration.
This will be the same for all the subsequent iterations throughout the quarter, iteration or sprint. If you wanna use a more agile term sprint I mean, iteration is also So
that's your homework. Okay? From this point on, I don't typically give other pieces for you to have to worry about. You know, you guys finished up your Srs, you're doing the Uml class diagram. But really, after those things, it's just write your code, you know. Maybe Update your Srs, maybe you update your Uml at some point down the road. But you're just in project mode. And so that's your homework. So
and so, yeah, every every week until we get pretty much to week 10. You'll work on an iteration, and you'll turn your materials in on Tuesdays. It's it's pretty straightforward stuff
I do like, I said. I assign points. It's 50 points possible.
That's if you put in a minimum of 7 h, and then you get me your screenshot. So I can see you guys did your work.
And so you get 50 points. If you fall short on your hours. Then then
You won't get full points, but I do let you make the points up, or or you know, on a subsequent iteration you just have to go beyond 9 h. And I would say that if you're busy. And so, yeah, I kind of show here, if you only get to 6 h for some reason that's 42, 5 h is 34, and on down
in terms of your points. But you can make them up. I know that sometimes you get busy. So let your team members know when life's happening to you. Let me know. You know, so that we're all in the loop and that we can work with you
and get you where you need to be. So
yeah, there we go. So so that's why I do the points individually, because different people are going to be able to put in a different amount of time. And you know, once again, I'll say it. I don't really typically have worries about it here in the graduate certificate. But make sure that you legitimately represent your hours right? If you, if you're not able to get to 7. You can make the hours up.
You know, like I said, just let me know. And
you don't have to make them all up the next iteration or sprint. You can do it over time, a little bit here and a little bit there, but but I do know from teaching this for quite some time, and an undergrad version as well that
you do need to get in
7 h to try and make sure that you're building a good product. You know, one that's complete and one that will stand up well.
not just to my scrutiny, as the you know, as your professor here in 504. But remember, I want part of your goal to be to take what you do and to post it to Github, to advertise your ability to potential employers. So that's really what I want you to get out of it, that making you ready for industry and making you ready for that. That 506 capstone course
in the spring. So so yeah, as you pull your stuff together, if any of this, if you're not sure about any of these. I'm just. I'm just looking for body of work reach out to me as necessary. But this usually doesn't cause too much fuss. So any questions about deliverables for your 1st iteration, and it'll be the same kind of thing for subsequent iterations.
Okay, very good, then.
And I did activate second iteration. Oh, we got something in the chat
So so the question is, what? What? What if you started your sprint
from the last week of January. Well, I think I mentioned it's okay. If you kind of started work, I just didn't formally ask you to monitor it if you. And and if you're asking that because
you feel like like I this past week I couldn't put any enough hours in, can I?
Can I pull in hours from the previous week.
I mean you, you know you just enter the hours.
You see, I worked on it this day or that day, or whatever you know on it's it's it's the honor system. I'm not. I'm not, gonna you know, worry too much. And so if you did some work previous to the 1st iteration. That's very specific to the project, and you wanted to count it and put an entry in.
You know, as part of the 1st iteration or 1st sprint, you know. Okay, all right, that's fine.
But but yeah, I didn't. I didn't have you formally monitor stuff until this past week. So
we're, we're just kind of easing into the project. So it's it's okay to do that. If you want. You know, I'm I'm glad to give you credit.
So yes, yeah, there you go. Okay.
and and, by the way, the the rest of you didn't see it in chat. That was a direct message to me, but it's something I felt that applied to all of you. So I said it out loud. So okay,
let's see.
So there's our zoom stuff. Let me see. Cloud recordings. Wait a minute. Oh, this thing fell asleep on me
goes to sleep.
There they are. Yeah, there's all the recordings. Okay? So we don't need to look at zoom. We talked about that. And so let me go back to
okay. So let me go back to our little agenda here. Which is posted under under
module 5. All right. So we talked about iteration. We talked about quiz. We talked about. Srs, you guys did a great job. So you're working on your draft of your email class diagram. And I think I set the due date, for
this is like Monday, or something, or Tuesday, or pretty soon.
I guess I can look at. I can look here under assignments and see. So your uml is due tomorrow.
Alright. So tomorrow, before the clock strikes midnight.
I would say. You know my idea was, try and have it done before you started your second iteration. So finish it up as part of your 1st and so if you, if you found you needed a little extra time. Just just let me know and I'll give you extra time. But
so oh, there it is, and thanks Janine for putting. Yeah, it's the it's the 9th
so are there, I mean, how's it going? Are there any questions and clarify or clarifications with regards to to your Uml class diagram draft. It's a draft.
This is the beginning of your project. It's not going to be perfect. Just try and consider the set of classes that you think you're gonna need for your solution. Okay, it's gonna change. The contents of those classes are going to change.
But the more that you nail down now the better off you're going to be. And so I do want to for those of you that are doing the dungeon adventure. That stuff is is pretty well laid out, you know. You've got some stuff from 502. You've got your code base from there, and then, you know, I have a set of classes. It's like, here's this inheritance, hierarchy that you need to build, and some other discussion. And so so I wanted to talk to those of you that are doing the file watcher.
And so the file watcher, in terms of the number of classes, I think, is is probably going to have quite a bit fewer classes than the dungeon adventure. The scope of the file watcher is smaller, you know, which is fine and
so so yeah, if you feel like when you develop the Uml for that?
We're gonna use this model view controller. And so you know, all of the all of the file watching basic pieces and so let me go to
our course project here.
Okay? And so our our file watcher, I'll just open this
right. So you're gonna use watchdog.
Okay? And so
and so there's, so this is the thing is that there's these code examples that you can use that that show you how to import all right, and then to listen for the events. So you're so you're gonna you're gonna explore what this does. But there's there's code examples that walk you through, how to wire everything in. And then I also provided, of course.
some other.
Well, maybe that's ended up being the same thing. Did I do the same thing?
Sean Warlick
Sean Warlick
00:45:47
Yeah, it's the same.
Tom Capaul
Tom Capaul
00:45:48
Yes, I did. Sorry about that.
Sean Warlick
Sean Warlick
00:45:51
The Katie nuggets is the most useful of them.
Tom Capaul
Tom Capaul
00:45:53
Yes, yes, this is the one that I liked, and so
so so the stuff that you have here oops the stuff that you have here.
The the basic watchdog stuff.
That wants to live for the most part in the model
and then any of the gui stuff, right? You know. So depending on what toolkit if you like to do, tk, enter, or something like that, that's gonna represent the view.
A lot of times in basic Gui applications controller code.
You know, the Controller code move stuff back and forth between the model and the view. It's it's home base. And I don't want to look at a code example. But but just think about all of the the basic under the hood functionality of the file of this watchdog.
It's it wants to live in the model
and there can be a notification process. So this is the observer pattern that we'll talk a little bit more about and look at an example today. But
what's going on in the model with your watcher when some kind of an event occurs.
You know. Okay, we just had this file that was created in this directory. And so then that needs to get reported to the view.
So you know, if you if you use the observer pattern, then you can just notify the view, whatever class or classes it is that you have in the view, have registered
with the appropriate class in the model. And that's part of what this code example shows. But
the thing about model view controller, which sometimes causes confusion is the amount of flexibility that it provides. You feel like you need to try and do all these different things. But what you do with model view controller
is number one. You separate the model from the view number 2. The model does not interact with the user in any way, shape or form. So those are the 2 main concerns. Then, if you do that, you separate the model from the view.
then
then your your controller code. Oftentimes, like I said before, it's just going to move. Something happens over in the Model Controller code could be the code that says, Oh.
this just happened in the model. Let me grab that data and send it to the view.
Or
if you set up an observer version of Mvc. The model can just notify the view. If you use the observer pattern where the view registers with the model.
and then whenever the model changes state and the way it's gonna change. State is one of those events occurs. Hey? A file just got created. Oh, a file just got renamed. Oh, this thing got changed!
Those are all those are all events. And so those are a part of what's going on in the model.
And so then there just needs to be a notification process, so that the view.
so to speak, hears about it is notified, and then the view decides how it wants to display it. Right?
And and you know, maybe you decide that you're gonna put it in some kind of a text field. Or you know who knows what kind of a Gui component that's that's up to you and your team members to decide. But
but your Uml, for the file watcher is probably not going to be as big especially to start off. It won't be as big. You'll you'll discover pieces as you go, and so it's a draft, so what I'll care about is that you put reasonable thought into it. Body of work, reasonable effort, and you'll probably get full points.
The thing about it is because they're drafts. If I find problems with it, and I and I end up taking points off, then I'll let you fix it and get the points back, because it's a draft.
So
so yeah, probably what you're doing or thinking about is fine. And if you feel like man, we don't have a whole lot of classes here for file watcher. That's probably the case. And and just a reminder. It's my 1st time giving this
as a project. So I'm working out the kinks a little bit. Don't be shy about asking me questions and clarifying things as necessary, because it is new, and and there are there are pieces that I'll still need to add to help you out
in in terms of well, not just guidance, but expectations. So, okay, so yeah, that
that's what I wanted to mention about your Uml class diagram. Try and make sure you get your symbols right in terms of how those classes are related to one another.
yeah, any questions about what you got going on?
Okay?
So oh, we got something in the chat.
Okay, Janine says, none so far.
Okay?
And so I just I do. I want you guys to know you're very quiet. You're a quiet bunch. You're very attentive, which I appreciate. But it is like a hundred percent. Okay to just unmute and say, Tom.
alright, you drop it in the chat. But it's okay to unmute
so just just so, you know, maybe you're just like Nope, I don't have a microphone or something like that. But but it's it's way. Okay, I will never be offended if you unmute and say, Hey, Tom?
So okay, well, we're gonna move on and so let's let's talk about the software lifecycle. And so it is from there. There's slides from Module one.
and I have them open up here, so and it's 1 of those I I intended to go through it. I mentioned it at some level. But these are. These are my steps from the software lifecycle, depending on who you talk to. If you look around you'll get a a slightly different list. But but I feel like mine is is pretty representative. So
and so, yeah, at the inception of your software, there's what's known as the analysis phase.
Sometimes it's phase 0 or step 0 in the software lifecycle, and so and so, yeah, as the as the the letters here say with analysis, you, you say, is, is there a need?
Is there something?
Is there a problem that that needs solved?
And can we satisfy that need? Or can we solve it with software?
Okay, is there an opportunity to write some software to do this thing whatever it is? And then. So part of what you look at is, do we does our team? Does our development team? Does our company do we have the skill
to build the software to do this thing. And then the other thing that you look at is, you know, can we afford it? What kind of costs are associated with it, and so the the cost could be in terms of person hours. It could be in terms of materials, you know different kinds of resources there and then another thing that that you might ask is, will it be worth it? Are you doing this to try? And, you know, earn money?
Yeah, it might be that your software, you know, shop is part of a larger company. And you're building software to support other people in the company.
And so maybe the will it be worth? It isn't as much of a concern. But in general this is something that you think about as part of analysis. And so I didn't put the word in here. But what analysis is about
is risk.
Okay, is, you know, are we? Are we willing to take on the risk all right to to try and build
a piece of software to solve whatever problem it is that that we think exists.
And I'm saying problem. That's a very, very loose term.
So because
what it might be is you decide, oh, we want to build this game, and so we could be kind of silly and say, Well, the problem that needs solved is, there's no game like this of this genre that does the things that we're going to do. That's this cool or this fun or this interesting, you know, so that people want to give us their money. You know, to play it.
So so you get the idea, this is talking in very general terms. So so it's about risk, you know. Is there a need? Can we satisfy the need with software? Do we have the skill? Can we afford it? And ultimately will it be worth it?
So that's analysis.
Alright, and so then our requirements and specifications. And you guys did a wonderful job of building Srs draft for your project. And so they very much go hand in hand, right? And as we've discussed and and did a little bit of review here today. They're concerned with the who, what, where? When? Why.
and we already learned to build an Srs. You went through that, and you you already did this part. So the other things that I that I didn't say about the well
with requirements and specifications. It's specific to the Srs. The Srs is a roadmap to your software. It's a living document. It'll evolve. It's a communication piece, all of those but requirements and specifications very much. Who? What? Where? When, and why?
Okay? So then, following the the requirements and specifications comes design.
I should mention that as we talk about these phases of the software lifecycle.
agile methodologies. And so iterations and sprints. And that's that's what we're doing right here. We still haven't gone through and formally defined a lot of the pieces of agile, because I've been trying to get you into project mode sooner than later. So and so there's a lot of overlap between these different phases and an important thing to note with agile methodologies for each iteration or sprint. You can actually go through
most of these steps or phases of the software lifecycle for each sprint. So so at the start of each sprint or iteration, you know, you can. You can. And you can do an analysis and look at where things are at. You know. Look at your requirements and specifications. Update them as necessary and part of that then could be, oh, we need to write some more user stories. We need to write some new things because we realized from the previous sprint iteration. We. We didn't consider this stuff, and it's pretty mission critical.
So so anyways, there's tend to tends to be overlap between these things. So design. That's the how
done on paper. So a uml class diagram.
That's design. Arguably a use case where you where you have your little use case
diagram with a little stick. Figure and then the oval
you know that's some some form of design. And then a a use case description step by step, scenario that describes typically user interaction with the software. Technically, that stuff is design. But I mentioned this. And we saw this in our examples that we looked at with the Srs, sometimes that stuff sneaks into an Srs, and that's okay. That's okay. Other things that can be designed. Pseudo code.
So you know, you guys, are, you guys are dealing with 5 0 3 algorithms. And so it's very natural when you need to solve a problem, to write it up in pseudocode right? And so.
And the good news about spending the time on pseudocode is that if you properly define a given algorithm, then the next step, which is implementation writing code, is just a matter of translating the pseudocode to the programming language of choice, you know whether that's python or whatever else. So
the more time that you spend on design.
Okay, then the easier the implementation part. That's where you write, the code becomes
all right. It's a tendency for beginning programmers, you know, junior developers is the term that I like to use. You know, as you're going through a degree program that whether it's undergraduate or for you guys here in the graduate certificate, the tendency is to want to jump to the code right away.
because because that's where you see tangible results. It's kind of. I think I know it is for me still is for me. It's my happy place. I like writing code because I'm building. I'm really building something, and then I can run it
usually and see results. And so, you know you. You get that feedback and the gratification for the work you put in the other stuff, you know, building an Srs and doing design. It's mission critical stuff, but it's it's not as glamorous. And so
and so, maybe for some, it's not always as fun or interesting. But but do understand, it's really important if you're if you're building a piece of software of any consequence, size, wise and ability going through these different phases of the lifecycle does matter.
And so, yeah, implementation. This is where you write the code. And as I mentioned, if you have a good and thorough design, then much of your implementation is just a translation.
Okay? So then, after implementation. So you've written the code, there's testing and debugging. And I just have a you know, those are pretty self explanatory testing what you've built, debugging. So figuring out when you've got problem areas when things aren't working right ironing, ironing out that stuff and cleaning it up.
But testing and debugging should occur throughout the lifecycle. You know. But here it means formal testing. Once you feel your code is complete, so you can think of what I'm describing here under testing and debugging as systems, testing
testing the entire, the entire system as it exists at that point in time. When you're writing code. You guys know this. And so with your little minesweeper, you had to do some unit tests. And you guys did a good job with that.
so
unit tests, you're going to write just as part of writing code. Technically, there are also what are called integration testing, which is a step up from unit tests. It's it's when you have multiple modules, for example, in Python. And they need to talk to one another. Integration testing would make sure they're talking properly. And you're getting the results that you expected.
Okay, so then, so there's testing and debugging and then assuming you've gone through that. And you're okay. You're like, okay, testing and debugging. We're in good shape. Then there's documentation.
Okay? And so documentation. It depends on your audience. But you can have documentation for other developers. And so in python, when you guys are doing the doc string stuff, the triple quotes that's for other developers, all right. But then we can have documentation. Maybe your application has an admin role.
And so then you need to have some directions on how to administer user accounts and whatever and permissions and those kinds of things. And so so you need some form of documentation there. Maybe it's HTML, maybe it's a Pdf Pdfs pretty standard anymore, right with links to examples. And it, it could be a link to a video on Youtube that describes how to use it. That's a very normal thing now, in this day and age as well.
and then, you know, similar to administrators. What about your end? Users right to describe for them so could be a Pdf could be. HTML could be images could be a recording on Youtube so
or somewhere else.
Okay, so that's documentation. Don't confuse documentation with comments. Comments are the inline things that are very specifically for developers. And so so a comment that would be in Python. That's where you're doing the little
number sign right pound sign thing. Just the inline comments. So not the doc string stuff.
you know. And and with comments those are usually there to describe why you did something a particular way.
We like to be careful with comments. We don't. We don't want to litter our code with too many of them, because then the code becomes hard to read. And if you have a lot of comments, maybe the code itself wasn't written as cleanly as it could have been. And the other danger is that comments become stale.
You change your code. Did you change the comments? Do they? Do they match the code still. So you got to be careful with those. It's a little bit tangent to our discussion here of a of a software lifecycle. But I wanted to sprinkle that in because it's important.
Okay? So deployment.
Sean Warlick
Sean Warlick
01:02:29
Friday morning.
going down a rabbit hole from a project I inherited from somebody else, and it was all because of a comment. It was out of date.
Tom Capaul
Tom Capaul
01:02:37
Yep, there you go, sean spot on, and I've been there and done that, too, and usually the guilty party for me with with comments is myself.
So I'll revisit something I did a month later, and I'll see this comment, and it's like what? And then look at the code, and I'm like, why don't I understand my code? Because I changed the code, and the comment doesn't match it anymore. So yes, comments, steal comments. You know, it's it's it's it's like freezer burned ice cream. It's just just get rid of it. Oh, it's just terrible. It just doesn't work. So anyways, deployment
deployment yes, janine.
Jannine G. D. MacGormain
Jannine G. D. MacGormain
01:03:17
I was just wondering, Professor Tom, out of curiosity, because I've encountered Doc string comments, terminology, and also comments. So it's it's quite confusing. But I I see I know the difference. But I encountered those word
combined together.
So the dogs ring, comments and comments.
Tom Capaul
Tom Capaul
01:03:40
So. So, Doc, String, the triple, quotes. That is the formal way that you document your code in python. And so you're going to use Doc string comments to describe any class that you write, and then any function or method. If you, depending on how you want to describe it, I'll use, object oriented, speak and say methods. And so you want Doc strings to describe your methods. So classes and methods. That's what Doc strings are for. And so
the things that you're going to include in a doc string for a method are, what are the parameters to the method? Right? What's being passed into this method, and what what values are returned from a method?
And also, perhaps, does this method? Does it raise any exceptions? Right? So so those are things that are going to be part of a doc string comment that you'll put on top of a given method.
and so and so like, and you may have noticed. I don't know if you guys have noticed this, but when you're in Pycharm, if you've put in Doc string comments, you might be in some other file, other python file, but and you've done an import, and if you point at, if you've made a variable of some type from from one of the other python files, you know. It'll bring up the doc string support for the name of that class, or the name of the function or method
and so and so that's that's what Doc strings are for. They're they're what are known as api documentation. So application programmer, interface documentation, Doc string are are the formal way
to describe
your python code, especially because we're we're looking at it from an object oriented standpoint like, I said, a nice description of what a class is about. And then all of the methods that that class happens to contain.
So the the comments, okay, the the little
number sign pound sign those are just in line to kinda show what was going on like when I put them in. It's like what was, why did I do some something this way, and it might be you have to do it this way, because if you use this other thing here, it's really slow. You know or it. It doesn't always behave as expected or you like comments to say why you did something.
It. It's okay. If they say what is going on but a lot of times. The what part? If you just use good names and and those kinds of things? Then the the code is kind of describes what it does all by itself.
You like comments to say why? And so
comments that, like I said, the number sign pound sign. Those are in line things. And so they're not part of that large documentation suite.
Like like doctrine. Wants to do some of you know, Java, and so Java has Java, Doc.
and so the Java doc is for the classes and the methods. And then there's inline comments which are just
2 forward slashes for for a single line comment. And that's, of course, what we can do in python with the with the pound sign or the number sign. So does does that make a little bit of sense, Janine? Does that help at all?
Jannine G. D. MacGormain
Jannine G. D. MacGormain
01:06:57
So basically, Professor Tom, the Doc string is an overview of your description with your entire class, or either. It's you're describing the methods and for the comments itself, it's just a snippet of small details of the complex logic you're implementing.
Tom Capaul
Tom Capaul
01:07:12
Yep, spot on so.
Jannine G. D. MacGormain
Jannine G. D. MacGormain
01:07:14
Thank you.
Tom Capaul
Tom Capaul
01:07:15
So you you think about the Doc strings as all right, some other developer. They're going to need to work with my code. And you know this Doc string stuff.
And actually, you know, there's a tool in in Picharm that'll consolidate all your doc string into into a true set of a document that describes all that. Here's the class. Here's the functions or methods that are associated with the class. But like I, said, the Doc string stuff you're going to say, here are the parameters meaning the things we're passing to this function. And you can say the type of data you could even say the expected range of values for those things. If you want
other things that you can list that probably you haven't really talked about in 502, and we haven't talked about it. Here is that for any function or method that you write, you can list part of what you put in a Doc. String is like precondition. So what things need to be in place when this function or method is called so that it operates as expected. And so you can also put post condition
meaning what things are are gonna be true, or what are the results? Gonna be? What's going to be produced once this function is done doing its thing.
You can even include these things called invariants. And an invariant is something that's always true while that function, while that code happens to be executing, and sometimes that can be important to to make a note of. So the Doc string stuff is where you're formally describing.
All right. The the major pieces.
Of your software. For other developers. So
yes, it's it's the formal tool.
So there you go. Alright. Good.
So we're at deployment.
So yeah, installing a plot, you know, on on the software, or sorry installing the software on the platform that it'll run. And of course, making sure it works that can involve documentation and maybe training on how to configure the software. Maybe it's simple enough where there's just an installer
So there's a lot of things that go into deployment because there maybe are some dependencies for your software. What other things does it require to run like if you write a python application. Well, the machine that you're running it on needs to have python, not just any python. It has to be at least the version of python that you programmed against. And so that's part of the whole deployment thing. Other things with deployment. You have to make sure that you don't break
the other things on the existing system.
Other programs that used to work should still work after you install yours. I've seen scenarios where that's not the case. So so yeah, there's deployment. There might be training depending on the software could be for Admins. And then certainly for whoever's using the software in general
and so that training could be in person. Things it could be recordings. It could be, you know, it could be a part of a help suite the documentation suite.
But but training is a thing to consider for software. Also, there's maintenance.
Okay? So bug fixes maintenance also is coming up with new versions of that software. So making some improvements, new set of features, revised set of features, you know streamlining things. That's all part of maintenance, and of course, in this day and age you better have an eye on security. So so security patches. You could argue that. That's a bug problem, too. But security specific, you know you don't. You don't want to leak information or you know, who knows? So
could be? Oh, yeah, we just realized we were vulnerable to SQL injection. So software runs fine. But we can get SQL. Injected and an attacker can discover the contents of the database, or they can add them as a admin to the database. And so
that's where you would need to be or have a security patch. And so then, finally, there's retirement. So maybe formally stopping support for a product. And it could mean that you remove access to that product if possible. In reality, that can be pretty hard to do. Some people will have some version, and then they'll plop it up somewhere, or for other people to download. You know, when you think about Microsoft and Apple.
you know, when they come out with new versions of operating systems, they reach a point where they say, Hey, this version here from however, many years ago. We're no longer going to formally support it.
you know. And so, you know, for Microsoft they stopped supporting windows 7, you know, a long time ago, and I think I think windows 8 vista.
So because to to continue to support those costs money, and the the fact is, those older OS's, you're not making money off of anymore. But you have to spend developer time. And the thing about older versions is they typically aren't as good as newer versions. They they might not be as secure. And so
and so yeah, part of the reason why you do new versions is the old one just had a lot of issues. We need something new because of security holes and who knows what else? It was buggy. So you really do. There are times when you just want to stop formally supporting things. Another thing that I'll bring up that's tough for companies. It's something we expect as an end users, but as companies, it's it's tough, and that's backwards compatibility.
So certainly, if you're a game player, you can get frustrated with certain companies out there because they'll come out with a new gaming system. And it's like I spent all this money on all these games for the previous gaming system, and it says that the the new system isn't backwards compatible. And so it's like those buggers they're making me buy brand new versions of this, you know, and and so
But but the thing about it is when you come up with a brand new set of hardware, and maybe you build a completely different underlying operating system, because you're truly trying to improve performance and everything else, and so to maintain backwards compatibility. Once again it just it costs money and a return on investment. You know you're supporting stuff that people have already paid for some time ago. So it's just kind of tough with the business model
you want to do the right thing at some level. But but you also want to pay the bills. So anyways, this, my friends, is the software lifecycle. And so I could ask you. You know, a question or 2 on the quiz about these, and of course you get to build a cheat sheet so you can grab this. And if you took any notes, because I, of course, supplemented what what this stuff had to say. If you include that kind of stuff in your little cheat sheet, you should be in good shape.
So any questions or comments or clarification on the software lifecycle is what it is right.
Sean Warlick
Sean Warlick
01:14:15
In your experience. How do you get companies to actually invest in the maintenance part of the life cycle?
Tom Capaul
Tom Capaul
01:14:20
Well, so good. Question. Maintenance actually is probably the biggest.
longest phase in the life cycle, that is, if your software is worth a darn, you know it persists over time. And so you know, the bug fixes
have to be done. You're like you're like, well, where's the money in fixing bugs. The problem is, when there's bugs in your software doesn't perform properly, the word gets out, and the same thing with security. Right? Oh, my gosh! There's no worse press than
your application had a security leak. It got hacked and user data was exposed for millions of users. Right? That's the kind of stuff, and then you go out of business. And so it's not too hard to have a commitment to fixing bugs, especially major ones, and then also security patches.
any software of any consequence. Size wise ships with bugs and continues to exist with known bugs. Decisions have to be made about how likely is it for this bug to arise and cause issues? You know. And sometimes you're like, this is really minimal. There's other stuff we have to focus on. 1st we're going to let this bug persist until we have time to patch it.
and then the security stuff, you know. That's more mission critical.
You don't get return on investment other than like, I said, it's bad press, and people will stop using your product if you don't fix those things so so the maintenance part and the buy in for those things, Sean. At least, in my opinion.
It, that's not too bad.
Improvements are a big piece of maintenance. New features. Right? You guys are doing dungeon adventure 2.0. Hey? Look now, you have all these characters, and they have these skills. Right? You know the cool thing about your dungeon adventure 2.0
is that if you do a good job with your object-oriented design, then doing a 3.0 where you have even more kinds of heroes and different kinds of special abilities, it becomes really easy to add additional features if you do good, solid, underlying design.
So
so yeah, I think that the maintenance part isn't bad getting companies to truly commit to building secure software. That's a tougher thing depending on what problem space the software lives in some of it, you know, when you when you're dealing with credit card data, those kinds of things. Well, you have to, of course, have security built in but one of the other hats I wear. I teach a class called secure coding principles, and I got to do a Sabbatical at Microsoft
about 20 years ago. Now. You know, when they were finally addressing the issue of how terrible their software was, and how how severely it lacks security. And so I got to understudy one of their top guys. And I built this class. And so
and so the file watcher thing that some of you guys are doing the company I worked for there. That was a they were big brother software. And so that that application that we wrote that software, we had to make sure it was very secure. It's like we can't let our application get hacked or attacked. So so we had very, very high commitment to no bugs, and making sure that what we did was done in a secure fashion.
so so long winded answer there for you, Sean, hopefully. That helps some
any any other follow up, or any other questions from anyone.
I see now in the chat. Janine's asking, what about usability and reliability? So so
those things would be a part of
to to find those things out, the usability and reliability. That's part of testing and so systems testing the usability that's end user or acceptance testing. I actually have a set of slides that we'll look at in a few more weeks on the different kinds of testing that that are involved with software there, there's so many
but but you know, to to mention
reliability and usability. Those are well, they're a little bit touchy, feely meaning they're subjective. One person will say, this is usable. Another person will say, No, it's not. One person will say this feels reliable. Somebody else will say, No, it's not so. So those are subjective
and and those things usability and reliability.
You know. And and this software is secure. Those are, those are what are known as non functional requirements for software. So they're subjective. One person might say, Yes, this is okay. Somebody else will say no.
It turns out as we talk about design patterns, design patterns. Help us with the non-functional requirements in our software. They help with reusability, usability, testability, maintainability. So
so many layers and so many pieces are interwoven to the things that we talk about here in 504 as we as we try and look at a bigger picture.
So
okay, this is good. You guys. Oh, see, this is what I love. You're asking really good questions. So and so we got to the point now, where we are certainly ready for a break. Let me go back real quick before we go to break alright. So we talked about the software lifecycle. And so, yes, we're gonna take a break and
we've talked about Mvc, I want to look at a little code example. Then we'll look at Observer. And then from the Lord of the Rings assignment that you guys had in 5 0, 2 and look at a code example there, couple of code of examples there and then mock object. And so
we'll see how we do getting through those things and those code examples. And then if we have time, we get through solids. If we don't get through solids, they're not on the quiz. Right? I listed agile manifesto, I said. Probably we're not going to talk about that and that stuff we can talk about when we meet next Saturday. And then there's these things called code smells that we're going to talk about. Those are potential problem areas in your code that definitely won't come until next week. But let's take our 10 min break here.
Okay, so we're at 2 50. Let's take a good solid 10, and we'll come back at 3 o'clock, and then we're going to look at code examples for Mvc. Observer and mock object. See you. Then
there we go.
Hey? I was thinking over. Break my friends about. I know that some of you
intend to take this certificate and then use it as a means for to get into a graduate program. So I can't remember how formally I mentioned this before, but formally I am a resource for you if you need a letter of recommendation. Now.
probably we need to get a little further in the quarter like it's probably better like the end of the quarter so that I can give a true assessment of of your ability as I see it. You know. Certainly.
you and I could talk and talk about you know how you did in in 5 0 1 and 5 0, 2 but
I am a resource, and I'm happy to help out. I do it every year with the graduate certificate cohort. Many former students in the in the graduate certificate have gone on to the graduate program at here at Uw Tacoma. So
if I write you a letter of recommendation, it has pretty nice weight. So Being co-chair of the program and and and having been here, I missed my 5th year. So
and so. Yeah, it matters, and so reach out to me if you have some interest, and I'll do it for other other schools as well. But we're just halfway through right now, so I'm getting a pretty good feel for what your ability is, but but for me to really write something that's robust, probably the end of the quarter. I know that. Uw Tacoma, you know, they have a we have a application deadline, so to speak, but it's soft.
because students in the graduate certificate in the past have been able to apply it later. And and while there's demand and it's competitive
we will, you know, if you're interested and you have good ability, we'll find a spot in our graduate program for you and our our graduate advisor. I think you guys may have worked with her, Rachel. She's pretty amazing. She can talk to you about the financial aid pieces and things like that for the graduate program.
And the other thing is that
just I think a year ago.
The graduate program is not formally requiring that you take the gre.
So and so that's 1 less thing to worry about.
That's kind of nice. So so the accessibility of the program is a little bit better.
Anyway. So I wanted to bring that up. I know some of you had some interest in that. And so I am most definitely a resource for you guys and can help try and help get you where you want to be as far as that goes. So
all right. Good.
Once again, let's move on. Let's get back down to business. Let me do a screen share.
Okay? And so we talked about model view controller. We went through notes. We went through slides, and and so I want to look at this, and it is a very simple code example. And
I suppose, a bit of a disclaimer that the code example is showing one possible implementation of model view controller. And it's very rudimentary.
So so let's look at it and talk about it. So this mvc.py, I have open in
my favorite little syntax, highlighting text editor, notepad plus plus So
okay? And so this, this example throws everything into one physical file. These would these would live. I mean, we can see there's a comment. model.py view, dot py controller.py
so crazy, simple example to show you how you might implement model view controller. And so the key thing once again is that you're separating the model from the view. The controller is the glue between those 2, and it can move things back and forth between the model and the view as necessary. Now, the thing about this example
is that there's there's not any user interaction which that would typically go through the view. So so there's no infrastructure to take what might have come in
to the view as input, and then send that on to the model. So so that's why this is a real, simple example, but it still gives you a feel for how you might wire things together. The the other way we could do things. And that's why I want to look at the old Lord of the rings example from 502 and an observer, because because that's a different way that we could set things up
for for the model ultimately to get information to the view. So in our model here, the model has this list of tasks
all right. And so then we can add a task all right, which just appends to that list. Okay? And then get tasks. Just returns the list list of tasks. Very simple code.
alright. And so the view all right. So this is for the user to see and interact with in this case. Just see, it's past the list of tasks, and then just walks through and prints them out
all right. And so the controller is what's moving stuff around. And the and the controller is what's home base?
All right. So and so with our Controller. It has a constructor in this example or Annette. It's a constructor that's past a model and a view object. And so it maintains references to each of those. That's a very, very normal thing for a controller to want to do. It's going to hold on to any of your main objects in your model, and any of your main objects in your view sometimes that's just one thing.
So you know, and and so for your
for your for for those of you doing dungeon adventure. Your controller might have a you might have a class called Dungeon.
and so it would have a reference to the dungeon which could have a 2D array of rooms and whatever, and it has the monsters in there and then. The other thing that that it might that the Controller might maintain is a reference to your hero, right? Which is, that's your adventurer. That's that's your you know. Well, it's a hero.
That inherits from dungeon characters. So so that's the stuff, maybe from the model that it that holds onto. And then from the view, whatever Gui, it is that you have, you know. If you've got some kind of a window, or whatever, then it would you would
that class you would create an instance of that, and the Controller code would hold on to that for those of you that are doing the file watcher. You know your watchdog object wants to live in the model
and then you might have some other classes in there that do some similar things. And so your controller would probably create an instance of the watchdog or a class that contains the watchdog and and interacts with it. To do what it needs to do on the model side of things, and then your gui, whatever window kind of stuff it is, you know, whatever class it is it contains that stuff. Then it would, then it would create an instance or hold a reference to that.
So and so our controller has this add task
all right where we can pass a task in, and we look at it. What it does, is it? So here's where the controller is handling the interaction between the model and the view. It's talking to each of them which Controller code can do. Is it mandatory that Controller code does that? No, this is just one possible way. So it says, Hey, model, I got a new task for you. So it calls the Add Task method on the model
alright. And then the other thing it does is it calls this update view, which is another method or function that belongs to the controller. All right. And so what update view does is it will ask the model for what tasks it currently has. Right? And then it passes those onto the view. It says, Hey, view display these tasks right here.
Okay? And so then, in main, which actually could be part of the controller if you wanted it to. it. It is kind of controller code, create an instance of the model.
create an instance of the view, create an actual instance of the controller
and pass it. That model and view that we're just created right? So that's this constructor. Call right here. All right. And so then we just see this controller add task to complete an assignment.
add task, prepare presentation. And
well, we just looked at the code, and we know that whenever we call add task, it's going to add it to the model and then update view, will query the model for what tasks it currently has, and then tell the view to display them. So this is one possible way to manage
here's what's going on in the model. We want to get this stuff to the view. So the controller is talking to the model. It's also talking to the view.
All right. It sits between the 2 of them. The Controller code is always intimate with the model and the view it has to be because it has to make calls on them. It needs to know what what functions or methods to call what data to pass. So I put this example up here because it does a fairly nice job of representing
potential infrastructure for your model view controller pattern.
So so yes, you could take this, you could use it
or not. Okay or not. So the other thing that we talked about okay
was, we talked a little bit about observer.
right? And so just a reminder that what observer wants to do is there's a subject. Okay? And so the subject has data
also called state
that other things those are the observers care about. How do they care about it? They just want to know with the subject. Okay, when you have something that changes when you have some state, some data that changes. We'd like to get to know, we'd like to get notified about those changes. And then we'll look at those changes and decide what we want to do with them, how we want to display them, you know, whatever so and so
the observer pattern has a subject.
and then it has an observer or observers, and the observer has to register with the subject, and any observer that's registered with the subject.
Anytime the subject changes, state, so its data changes in some way. What the subject will do is walk through its list of observers. How did it get the list. Those are the classes that registered with it, and so it will walk through its list of observers and notify them of hey, here's the thing about me that just changed. Here's here's the data about me that just changed. It could just send all of its data. But
but usually it's like, Here's what here's here's what changed about me.
And and so then those observers.
they get the data and they decide what they want to do with it
in a model view controller setup.
The model is the subject. It has the data or the state that will change the view wants to know when that data changes. And so and so the view can register with the model. And then anytime the model has a change
in its state. It can notify any of the views or observers that are registered to it. It's that simple. And so using observer makes it so that you don't have to have controller code
asking the model for something, and then saying, Hey, view! Here's this stuff from the model. I grabbed it for you. So and so once again, Model View Controller allows for different ways to wire things in.
to make it so that data from the model gets to the view and vice versa. Data from the view gets to the model. Now, data from the view is typically user input and the way that it almost always, always always gets to the model is because there's some controller code that reacts to whatever happened in the view. And then it makes calls on
on, you know, methods or functions in the model to say, hey? You know, this thing over here just happened. This button got clicked on to move east. You know, or the user just entered their name. And so, hey, model? Here's your hero's name, you know. You need to add that as the name, so
something along those lines so anyways.
Sean Warlick
Sean Warlick
01:34:05
This subject also referred to as the observable in some.
Tom Capaul
Tom Capaul
01:34:09
And that's yeah. I'm about to look at the right sean. So I'm about to look at the code example. And so subject
is also sometimes called observable and
the Java programming language has built in support in its Api.
So so Python has an Api, you know. That's that's the set of modules that it contains, that you can import that do different things. You know, math and and the Tk enter stuff. And and so, yeah, Python has those things. And so any programming language, it has an Api. And so in Java there is.
there's a class called observable, and that represents the subject. That's just another name for the subject. Why don't they call it subject? Subject is just a generic term. Observer, observable.
observable is something that can be observed. So. So that's how my brain
rationalizes the name and the vocabulary, and so and so I have open. So there's this lord of the ring example, and I have it open in pi charm.
And so I want to show you the infrastructure here. So this, maybe, is familiar to you from from when you had it back in
5 0 2.
And so you know. Recall. I guess I didn't. Oh, yeah, it's right here.
Will this open for me. Yeah.
So here's this assignment. Okay.
that you guys dealt with once upon a time, and so recall that there's the eye of Sauron.
all right, and
The eye of Sauron wants to know anytime.
There's a
There's enemies, and so the enemies are hobbits, dwarves, and elves and humans, and so and so
and so the I. I'm I'm sorry.
The the bad guys.
they're the observers. They want to know whenever there's enemies. And so the eye of Sauron is the observable or the subject
all right. And so so there's a couple of bad guys. There's there's Saruman, and then there's the witch King.
all right. And so, as part of the the little code that's shown here,
when we create this bad guy whose name is Saruman, and this other bad guy, whose name is the witch King. We pass in the eye, and so the eye is our observable.
which is our subject in the observer pattern, all right. And so
here, on this, this, this line where it says, I, dot set enemies all right. What this is going to do is this causes a change in state
in the eye. Okay? And so what this should do is trigger a notification process with all of the observers. And so it turns out that each of these bad guys as part of constructing a bad guy. So this is a constructor. Call right here. They will register
with the eye. Okay, so bad guys are the observers they're going to register with the eye of Sauron, which is an observable
also known as a subject.
Alright. So so this set enemies causes a notification process, and that's what the comment right here says.
all right. So then, we see Saruman is defeated
all right. And so what this does is this causes Saruman.
Okay, the bad guy that saw him on to unregister. Okay? So no longer registered with the I. So the defeated method causes an unregister process. When we construct a bad guy that's when they'll register.
Do you have to do it this way. No, that's just part of this silly little example that I cooked up once upon a time, many, many years ago. Yes, I read all the lord of the Rings books. And so did my kids and and we still watch the movies when we get together today. And my my kids are 23 and 25 now. So
so anyways, the code example that I have let me go back to Pychurn
is so. So I made a class here called observable.
all right. And so this observable class has a constructor. And so it has a list of observers.
Okay, so it has a list of observers.
and also one of the things that we need to keep track of
with our observable. This is our subject. This is also would be our model.
Okay, we need to keep track track of whether a change has occurred or not.
Okay. So that's part of the observer pattern infrastructure is, has a change occurred in the state or the data
alright. And so we want to mark that, to know, to notice, or or sorry to know whether or not we need to do a notification process.
So here's a little added, add observer, function or method.
and so so what's done here is, hey? Let's just add whatever it was that was passed in. That's an observer. We'll add it to the list of observers. A little defensive programming here to make sure that the same observer doesn't get added twice.
Maybe you think that's okay. But then they'd get notified twice. And is that what you really want? So and then here's a remove all right, and it just says, Hey, if if the observer that we want to remove is in the list of observers, then we remove them from the list. And then there's the notification process. Okay, so there's this, notify observers. State changed. Okay, so so this is this, this is just a pass in
whether or what the change has in state has been or set to. And so we make a check to see if a change has formally been represented here, meaning
this change right here. Got set to true somewhere. And that's actually just down here in the set change method.
And so if a change has occurred, then here's where we just walk through the list of observers and notify them.
It's really simple infrastructure.
Okay, so what you could do on your in your model view. Controller is in your model
all right. If you it could be your dungeon, and something changes in the dungeon. Move from one room to another. Whatever anything that causes the change of state, you could set up the infrastructure that you see right here to notify whatever code, or whatever class or classes it is that you have over in the view.
That's why I'm showing this. And remember, this example is posted under Module 4. So you could grab this and tweak it for your intents and purposes.
but anyways notify observers just walks through the list of observers and notifies them. The other thing it remembers to do is to clear the changed flag.
Okay? Because it's notification has occurred. So the change has been reported.
So so clear change just sets the change flag to false set, changed, sets it to true, has changed, just returns the value
alright, and then, just to know how many observers there are. This is just a little utility. How many? Yeah, count of observers, just a just a little piece as part of the solution.
So there's the observable. And so I have. Sauron.
Okay, this is this is our subject.
This would be our model.
all right, inherits from observable. So gets all the things that we just looked at here.
Excuse me.
And
so in its constructor, right? It calls the parent class constructor. So that's the observable constructor, which we just looked at
all right. And then the other thing is is that we're maintaining the count. So here's a tuple to represent
hobbits, dwarfs, elves and men
all right now, could we have had individual fields for that? Yeah, but this was a quick, quick, and dirty example, just of the observer pattern.
So set enemies set enemies we pass in. Here's how many hobbits and dwarves and elves and humans.
And so, just to to modularize things a little more. Let's call that the fellowship
alright. For those of you that have seen those movies or read the books, or both.
And so a quick check here that just says, well, if the if the fellowship isn't
isn't the same as the as the current count, so so just showing that it's different.
Then
let's go ahead and update the current. Count to the fellowship, which is just this stuff that was passed in. And then we set the change flag. Okay, so set change that was defined here in observable. And so this says, all right, we've just had a change occur
all right. And then in set enemies. There's a check and says, Well, if if a change has occurred, all right, which which would be the case if this conditional statement on line 21 evaluated to true. Obviously, then, okay, let's notify all of our observers.
And and what we do is we pass along the information. So the hobbit, count, the dwarf count, the elf count, and the human count just encapsulated into this single little variable called fellowship.
Alright, so so set enemies fires off a noti notification process. And so in the tester.
Okay, this is pretty much the code from the assignment.
Right? Here's how many hobbits and dwarves and elves and humans. Right? Create our ifsaron, create our our bad guys. All right. And so then this set enemies right that fires off like I said, the notification process. But the other piece that we need to look at is the observer part.
And so, observer, let's make it abstract, so we can never have something that's just an observer. And so a couple of abstract methods. Here the constructor
although although it is okay, python, lets us get away with murder? And so
we pass in to this constructor the observable
okay, so the observable ultimately in this scenario here is going to be the eye of Sauron.
All right, we'll see that this init is called from bad guy in just a sec. But observable add observer self. So that's the registration process for the current bad guy
who is an observer.
Okay? And then there's this notify method which isn't fleshed out right here, all right. But but there's this state change, which is just the information about whatever change occurred. It's the data. How many hobbits, dwarves, elves, and men.
or humans, gets passed in so bad. Guy
wants to be an observer. So bad Guy inherits from observer. All right. So so if you tried to put this observer infrastructure into your project, then, bad guy.
It's bad guy here, but it would be at whatever class it is. That's your view.
Okay? So it wants to be an observer. So here's its constructor. It it takes. We already saw this called over here in in the tester.
alright bad. Guy is past the I, and then the name of
what the bad guy is. But we're past the I. So that's our subject. That's our model.
Okay? And so we make a call to that superconstructor, which is the observer constructor right? And we pass along the eye. And we already saw what it does is it registers itself okay with the eye. So this is the registration process right here.
Okay, so what what we see here as bad guy.
this would be, whatever class it is you have in the view
that wants to register, to get notified whenever whatever class it is that's in the model. That's your subject changes
all right. And so here the notify method is fleshed out inside. Observer it was abstract.
but here it's fleshed out, and so state change that, as I said, that's the hobbits, dwarves and elves, and men. So let's just pull those values out. And then it just prints out, all right, you know so and so whatever the name of our bad guy is knows about. And then the hobbits, dwarves, elves and men or humans
defeated. Okay. Defeated. This causes an unregister. So the the observer has a reference to the subject here.
Okay, and that's important, so that it can unregister right here and remove itself.
So so this is the infrastructure. You guys lived this back in 502. I don't know how much you remember how hazy it is, but this the reason that you learned about observer was because it can be used. It's not its only case, but it can be used
all right for model view controller. And so just to finish up and move on
all right. You could set up this this observer class, and then maybe it's your dungeon. Maybe it's whatever class it is that you have in in your in the file watcher that's using watchdog.
that that's your that's your model. That's your subject. And so you would have it, just like I have Sauron right here, it would inherit from observable, and so that would give it the ability all right to it would have a list of observers right? It would have the ability for an observer to register and unregister. And then also this notify observers. So
the notify observers was called in set enemies right, you would tweak this, for you know.
it just depends, you guys, for those of you done dungeon adventure. Any function that you have in there that causes a change of state.
Then you could call notify
right? You could. You could do your your notify observers, and then, you know, it could be a move method. It could be an attack method. It could be. You name it. Just think about this thing right here is causing some data to change in the model. I'd like that information to get sent back to the view. So in any of those, then you would call that, notify observers and pass in the information. And then the observers, you know, this is the bad guys.
Okay, when they're when they're notified, gets called. Alright. Then you can decide what to do with whatever information happens to get passed.
So this is pretty neat, this this observer setup
and so different programming languages have some built-in infrastructure. I said, Java Java has an observable class and an observable interface. Python doesn't have interfaces per se. You have to make an abstract base class instead. But anyways, this is the infrastructure to allow the model when it changes
to notify the view, meaning something that's registered.
So so take this, use it if you want I think it's a pretty nice way to go and this does not require this does not require a controller to move stuff from the model over to the view the model that's our. That's our Ifsr on okay, our observable, it's just notifying directly notifying anything that's registered with it. And so that would be whatever class or classes you have in your view that think would be interested
in in changes.
So there you go. That's what's going on
hopefully. It makes a little sense because you saw this back in 502. You're seeing it again. You're a little bit more savvy. Any questions or clarifications.
and you could, of course, ask
other times. But anything right now.
Okay, very good. Then.
Oh, I just saw there's a
janine has. Can we write something like set enemies.
It's dwarves, self dot data.
You could. Yeah, if you wanted to. I mean, you can do
whatever you want to do with the data or to make the data consumable.
you know, by the view. Because the set enemies that's that's on the model side. Like, I said.
whatever method or methods or functions, if you want to call them that, that change the state or change the data.
you have an opportunity to notify any observers anything that's registered. So that would be a class or classes if you wanted. From the view.
you know, I recommend start really really simple. Of course you would do that. Okay, my model does one thing, you know, whether if you're doing file watcher, all I'm watching for is like a new file created. Let's say, let me put infrastructure in for that.
Okay? And then the dungeon, like, only thing I'm gonna worry about is moving. Let's not worry about battling. Let's not worry about picking things up. I move from one room to another. There's move method that I got called and so in there whenever move is called, whatever we move to, I'll do a notification process. So
yeah.
so much flexibility here. And and I just encourage you guys to reach out to me. I mean, talk to your team members as you put this stuff together, the model view stuff. And then listen. It's so easy for you guys to set up a zoom with me. We spend 1015 just looking at what you got and give you quick feedback.
You know, and and and boom, we're done, and you know, if you're doing it the right way or not. So
okay, well, I'm gonna move on because because I've only got you for 28 more minutes. Darn it, I know you're getting tired. But I just this stuff is so fun to me. I just love it. Okay? So let me close that and let me go back to
okay. So we looked at a little Mvc example. And then we looked at Observer, and I tried to talk about how you could apply that to your scenario for your project.
And so the other thing that I have. And so I put it under module 5, I think.
So. Properties.
Okay.
properties. I had mentioned that these things are very handy just in terms of of good object oriented design on python supports properties. And and you can actually use properties
for for some model view controller stuff, and so
let's take a look. So I've got a couple of links here this python property function.
And then
well, the geek for geeks link. So so let me go back to this. The geek for geeks link
this property function all right, allows you to specify a set of 4 other functions.
So so we don't care about the property function. I mean, you could use this. It's it's it's useful. And so you can. You can get a getter, a setter, and a and a deleter
And so there's a code example that shows that what I want to look at in terms of properties is the decorator. And so some of you have seen this before, and I and I remember in your code you. You work with this. I think some of you did this in your minesweeper.
So so let's look at this code example. Here. We've got this little class called Alphabet all right. And it's got a constructor that's passed a value. So so it's underlying instance field here is underscore value.
right? By the way, remember, we want all our data to be private, truly private. So that's double underscore. Right? So so do remember that as you start up your code bases for your project, all instance, data. We want to be private. And so formally, that's 2 underscores, the one underscore kind of means protected. We want 2 underscores. So that'll give us some that'll give us a little bit of protection.
Okay, so here's the property. It's called a decorator.
which believe it or not is another design pattern. And we're not gonna talk about it right now.
But but this at property.
Okay, so this this little tag or label what this does or what this says is that that this
function that we're writing called value? All right. It's setting it up as what's known as a property, all right. And so what that means is is that we're saying that value is going to be associated with some underlying instance field for our class. And in this case there's only one. And that's this guy here, this, this underscore value.
All right. And so, because this is a little proof of concept it, you don't usually have a print statement here, but it just says, Hey, we're we're we're getting the value. So this
this value here works as a getter
back in 5 0 2, you learned about getters and setters all right. And so this is just shorthand
forgetters and setters. You still have to write the code for the getters and setters
where it becomes nice, is
when you want to do what's called consume the property just meaning as a developer. You want to work with the property. So you have to put the infrastructure here. So you have to do the same busy work as writing a regular getter or setter, and so getter wants to return the underlying value. So that's what this does. And then so to set up the notation for for your setter as a property, we do have to say at value all right. And so this.
And then, dot setter, what it's doing is it's referring to this function here that you call value
all right. And so then the dot setter says very specifically to use this function right here. So notice, it's also called value. But this one has a parameter. All right. That is the value to assign.
So and yeah, there's a print statement. Because, like I said, this is a proof of concept. You wouldn't do this normally, probably, and then we assign the value that was passed in here with a setter. Now is this the best design? No, this is proof of concept. And so the best design, of course, would be to scrutinize this parameter here called value.
All right, and make sure it looks okay. And if it doesn't look okay, you'd raise an exception.
all right. But this is, in fact, going to under, or it's going to assign whatever was passed in to the underlying field
alright. And so there's also a deleter, and the deleter isn't 1 that you strictly need to implement at all. Just do you feel like you want to be able to get rid of
the underlying value that's associated with the field.
or or delete the field itself.
Probably you don't. I don't know that you need the deleter. It's just a part of the overall pattern, so there's a getter and a setter and a deleter. The confusing thing about the getter is, we don't say like we have value dot setter, you just say property and then value, and then you return it. That's that's the syntax for the getter
setter. You need to say, value dot setter. Okay, whatever we call this, which is value. And, by the way, Python doesn't care that the underlying instance field is named with underscore, and then the same name as this.
It's a convention. It's good to call them those things. And so for those of you doing the dungeon adventure, you know you could have you got your your instance? Field maybe hit points or health points. So so then you probably, you know, underscore underscore hit points, and then your your property here you could call it hit points
and then hit points dot setter, and so on.
Probably don't need the deleter. You probably leave that off. I don't ever use the deleter, but it's there. Okay, so then the the key piece here. All right. This is the advantage. All right, of of doing the property thing is down here. This is where we see the advantage. So.
So we see, all right, constructor. Call to our alphabet class, all right, and we pass in, Peter. And so that's the underlying value, is Peter
all right? And so when we print it out.
yeah, it'll say, getting value. And then it says, Peter, okay, so this notation right here, X dot value equals Diesel. All right. What this does with this notation here? Okay, we're accessing value. It looks like an attribute meaning the instance field.
But it's not. This is a property.
Okay?
All right, because the the value is actually underscore value. Or if you did a how, you really should do it, it'd be double underscore, and we wouldn't be able to say, X dot double underscore. So so what a property does is it? Lets us write code that looks like we're dealing with a variable or an instance field. But what this does is it calls the setter, and we can see that from the output right here, setting value to Diesel.
This notation on line 31
calls this value function right here it grabs what it sees on the right hand side of this assignment operator, which is Diesel, and it passes that in as a parameter to this underlying setter function.
So so where properties are nice is over here because we just get to write this code. It looks like we're directly assigning to a field. But no, it's going through a setter where we could scrub the data we could raise an exception if it didn't look right. And so and so it allows for nice design, but really easy usability.
Okay? And you might say, but how hard is it to just call a set value function or method?
True? It just. It just simplifies the syntax a little bit. And so some programming languages. Python has support for this. C. Sharp has support for this. Turns out the Java. Doesn't you just have to have getters and setters? So
it. It's just some shorthand notation from a from a class user standpoint, not an end user. But whoever's programming and wants to work with the class. Then they don't have to call the getters and setters. They just access things like this. So so that's the advantage.
And so I did want you to see that take it or leave it. But but that's the notion behind a property is is that it rolls up the getter and setter stuff
right? You still write the code for it inside the class. But then, the way that you consume a property is we just when we say, X dot value right there. That's calling this getter.
Okay? When we say X value here because it occurs on the left hand side of this assignment operation, the python interpreter knows. Oh, wait! We're doing an assignment operation, I know, to call the setter version of value and pass this thing along right here, this parameter value. That's Diesel. So it's really cool how it knows to do this.
and and to me it's very handy. I love properties. I love them.
Okay, you still writing getters and setters, but then it cleans up your syntax outside the class itself, so.
Sean Warlick
Sean Warlick
02:02:27
To use that setter in the construction with the init method, so that it runs the checks that you know you would otherwise do.
Tom Capaul
Tom Capaul
02:02:35
Could you do it? Could you do it down here? Well, the the let me think about it because
we need to.
Sean Warlick
Sean Warlick
02:02:44
Because otherwise you have to write that checking again.
Tom Capaul
Tom Capaul
02:02:47
Well, I'm worried that it's recursive, Sean, because.
Sean Warlick
Sean Warlick
02:02:51
Yeah.
Tom Capaul
Tom Capaul
02:02:51
We have to define. So on line 6, we have to define the variable
right itself dot value, I mean, here's the assignment operation. But we have to define it. So could we?
Could we just say.
I mean, this value is what's passed in here. I almost want the example to use a a few different parameter names because it's confusing value value value.
I don't know if we could.
I'm I'm trying to think, yeah, because you want to take the setter and do the error check. I get it 100. I'm just worried
because we have to have this defined, but maybe
it'll define it for us right there. If this is, you know, double underscore. I think you can do that. Python lets you get away with
so much.
Mostly it's beautiful.
yeah, that's a we could. We don't have time to try it now, because I want to move on. But yeah, could we? Instead of doing this inside the init, could we just say, knowing that we've defined this guy right here?
I mean. But but the thing is we we need to specify.
We need to perform an assignment operation, so it'll call the Saturn.
I guess you could directly call it, if that's what you're saying, I say, could we say
value and then pass in what was passed in here?
I think that'll work
so easy enough to try out. You know. Just just grab the code and and test it.
But, my only concern is having this instance. Field formally designed, defined.
But Python will, it'll let you define it somewhere else. Self. Dot says it's going to belong to the instance. And so
could we do an initial assignment there, I think Python will let us do it.
So, okay, good. So those are properties
and they are handy. They're not strictly necessary. But but I like them. And so I wanted you to know about.
Okay.
So mock object.
So mocks are super handy. When you're working well in something like a model view controller design for your software. And so mocks are great when the real thing isn't ready for use.
Okay, so under under module 4. Here, we've got some notes on mock object. Okay?
And so let's take a look, just open it up here.
So a mock. Okay, this is something that we naturally want to do in so many places, programming included. So so it's a mock up right? We do mockups all the time in the real world of stuff, right? Proof of concept. And so a mock object is this, it's a simulated object.
Alright, that mimics the behavior of real objects. But in controlled ways. So they're typically used to test the behavior of some other object.
Well, much like a crash test. Dummy is used to simulate the behavior of a human in a vehicle impact.
So the thing about mocks is that they contain enough state and or behavior to substitute for the real thing. They are extremely useful in unit testing. So where this is where this notion of mock is great. For you guys is okay. I'm working on the view. And my team members working over in the model and whatever class it is that they're working on in the model is not ready yet.
Okay, but I need to test my view. I just, I just need some simple data. I just need a monster. Okay? Or you know, I just need a file event to have occurred. You know, here's this file right here in this Directory was created. And so I just need that for testing.
So let me make a mock up of the real thing. The real thing's not ready. But let me make a mock version of it. So the mock doesn't have all the behavior of the real thing. It has just enough stuff
for me to test my thing over here in the view, for example.
Hey, look, there's a picture of a crash system.
Okay?
So so you guys may have had some exposure to the factory design pattern in case we haven't, I'll talk about it
probably next week. So we use factories to build things usually things that are related in some ways like like an inheritance, hierarchy
for those of you that are doing the dungeon adventure. One of the things that I want you to do is have a monster factory, so it knows how to make monsters. You could also have a hero factory. There's not as much of a need for that for the file watcher. If anybody did the trivia maze, there's different kinds of trivia questions. And so you could have a factory to make a multiple choice question. And another factory could also make a short answer.
Multimedia question, who knows but anyways with factory, what this shows in the Uml abstract methods just means it's a, it's just some kind of a parent class. And so the real. So where it says real access layer implementation.
That is. So that's the real thing. Okay? And what this says is, we could do a mock version. So so they both inherit from the same parent class or base class or super class. All that means the same thing. And the factory. You could tell the factory, hey?
I want you to make me a mock version, or I want you. I want you to make me a real version.
And so this just shows you have an opportunity. If you have a factory pattern in place that it can make mock versions of the stuff that you that you want, because those are useful for testing.
And so mocks can be used in a variety of other patterns. You guys know about observer, we're talking about model view controller. It's it's useful. There. Maybe you learned a little bit about strategy back in 502. I remember I did a little robot example back then, and the robot could move in different ways. So maybe you saw that robot example or not? Whatever.
And so yeah, mocks are about testing. So they substitute for a real object during tests when the real object well, there's a lot of different reasons. So one of them is that the real object supplies non-deterministic results, meaning those are somewhat, or maybe completely unpredictable.
So as an example, it could be a temperature. So so it could be, yeah, we want to run. We want to run a test here, testing this thing over here. But but we need the temperature to be 70 degrees, because when it's 70 degrees, the A/C should turn on, or something right? Well, it's wintertime in Puget Sound, and you know, if it's outside or something, it's like it ain't gonna be 70 degrees till you know
May or June, probably.
You know. Maybe maybe we get lucky in April. But or like a current time, it's like this thing here. We want to test that this thing goes off at midnight.
you know, or 2 Am. Or whatever. Well, if you're depending on an actual clock that doesn't work, and so you can. You can see the need. It's like, well, we just need to mock that up. Let's set it up and say the clock is midnight. Right? Let's set it up and say that their thermostat has a temperature of 70 or 72, or something like that. So so that's an example of mocking it. So a lot of times, it just means you hard code, some data.
Or if you were, if you were calling a method or a function, you know, that wanted to return the current temperature. A mock version of it. You would just hard code it to return.
Oh, it's temperature of 70. 0, the current time is midnight.
So you you probably have already done mock kinds of things with other code that you've written. We're just formalizing it here.
So another thing about where you might want to use a mock instead of the real thing is the real thing has states that are maybe difficult to create or even reproduce. So, example being something like a network error.
So you know, how do you simulate a network error? Do you go turn off your Wi-fi router, or something like that. I mean, you don't have access to that. So so you know you mock it up. You just say, well, we'll just pretend it's not there. Another reason you might want to use a mock is that the real thing is slow to test. Maybe the real thing
it has to access a database which lives somewhere else. You know it lives in the cloud. And so you got to go connect to it, and depending on the traffic, and you know it could take a while to run a query against that database and get information. So it's like, yeah, the real thing is just slow, and for testing we don't need the real thing. We can mock things up and get enough data and go from there. And the other thing I mentioned is that the real thing does not yet exist.
still under still under construction, or whatever your team members still working on it. Or maybe it's gonna change. It's you know, it's gonna change at some point. You don't know what it's gonna look like later. So let's mock it up.
And then the last one here you'd have to include inside the real class methods or functions, if you want to call them that exclusively for testing purposes which breaks what's known as the single responsibility principle. That's the essence solid that it looks like we're not going to get to solid today, so I won't put that on the quiz.
No big deal. So we're not gonna have agile manifesto stuff. We won't. We won't have. We won't have solids on the quiz. There's plenty of other stuff.
Like, I said, I'm not. I'm not trying to overwhelm me with the quiz like, what have we talked about? I'll ask you some questions. So so, yeah, we we like to. And some of you, you know, might have found this when you wrote your unit tests. It's like, I want to test all these these functions and whatever but or look at data. But I don't. The data is private and my unit tests. They live somewhere else, and so they can't maybe access the private data. Well, that's where properties are nice to have, because then they can let you access that things, those those things from outside.
But but not actually directly access the underlying instance data.
And so here's a picture. The resolution is not the greatest sorry about that. But at the top there's we've got our business logic. So just that's your client class. And it wants to work with some data.
And so it's kind of hard to read. But it says, I, my data access. The I is for interface.
So some programming languages or just some companies, software development companies use an I to designate something as an interface. Of course you need to use a programming language that formally supports interfaces. And so Java does, and C. Sharp does. There's a couple of other ones. So that I means it's an interface. And so an interface is kind of like an app. It's like an ABC in python abstract based class.
So so you won't ever have an instance of something that's just an interface. But the key thing is that this business logic is gonna work through this interface.
all right. And so we if we have our real thing here. So we see on the left data access. And then a data store. So that's the real implementation. And then over on the right hand side is the mock implementation they both inherit from the same interface or the same abstraction. And so if I scroll back real fast and go here
all right, what we just saw down below abstract methods, that's the I, my data access. And then there's a mock version. And then there's a real version. So this is just a different view of the same thing. We just saw up above.
Alright. And so here's the thing, the business logic. Call it your client.
It's working through this interface, this, this abstraction. Think abstract, base class. We can plug in a mock version. We can plug in the real version the client, the business logic. It doesn't know.
It doesn't know if it's a mock or a real thing, all right, because it's working through that super type.
We just plug in whichever one we want. So and so yeah, this next slide mocks implement or want to implement the same interface so super type as the real object. This allows the client. This allows the business logic on this slide here to remain unaware of whether it's a real or a mock.
It happens to be an application of what's called dependency injection. We'll talk about that in a few more weeks.
It's another pattern.
like, what is it? With all these patterns? They must be kind of important. Yup, okay. In the world of oo design patterns are tried and true design expertise. Hey? When you're doing things like this, when you have a Gui setup. This model view controller pattern
has some real advantages for your infrastructure and your development and your testing and everything else. So maybe you want to use it all right. And there's Observer. And there's all these others. So they have. These are tried and true design expertise. So we'll talk about dependency injection later.
But mock object frameworks allow the programmer to specify which and in what order, methods will be invoked on a mock object, all right, and what parameters will be passed to them. And so complex behaviors like network sockets, or whatever else
things that are non-deterministic can be mimicked
all right. And so, oh, yeah, I forgot, I have this silly slide. So maybe maybe you've seen Spongebob before my kids grew up watching Spongebob. So I got to grow up with them, watching Spongebob. And so so in the background is the real Mr. Krabs, and on the left is a robot version. That's the mock.
And so Spongebob can't tell the difference between the 2. He thinks they're the same thing. He's the client. He's the business logic. And so he's about to hand over the secret Krabby Patty formula to the mock version of Mr. Crabs, which some of you will know as the evil plankton. So.
and so, finishing up the discussion here, mocks, fakes, stubs. Those terms tend to get used interchangeably. Fakes, you could argue, are simpler meaning. They implement the same interface, but but they don't do anything. So you've got a method or function. If the function wants to return an integer, it would just return 0. If it doesn't have a return type at all, then it just doesn't do anything.
So. So that's what a that's what a fake is. Fakes are sometimes called stubs. So, but these terms get used interchangeably. It's just not the real thing.
Alright. You can have what's known as a null object
which doesn't really matter to us.
Believe it or not. Yes, it's another design pattern. So
so yeah, mocks are used for testing. And so I wanted you to have this awareness as you get into project mode and start writing your code. Noting that my team member stuff isn't ready yet. Oh, can I make a mock version, or can my team member provide me a mock version of it so that I can do some testing. So so it's really nice. And so with the 3 min that I have left
I have so under. So this is Module 5.
No, I put it under module 4.
Okay, there's this code example, mock object. So in pie charm, all right.
here's what's going on with mock.
Okay? So it happens to be the one project that no team chose this quarter all right. And so that's the trivia maze. I kind of did it based off of that. But
so I wrote this class called question, okay? And so this would be our super type, okay or interface. So abstract based class. And so what I said is a question this question class? I can ask for a true false question. I can ask for a short answer question
all right. But at this level they're not defined. Okay? So they're abstract methods, all right. And I just put a pass there. So there's no code associated with them at all. And so@firstst So I know, I need a question.
okay, and and I'm going to have a real version of it. And ultimately the real version of the question will come from a database all right. But hey, the database isn't ready yet. So my team members working on this, I need a question for testing. And so if we have
this abstraction. So this abstract base class called question, okay, this could be dungeon character. You know, this. This could be so many other things I could make a mock version.
Here's my mock version. It inherits from question, and then I provide an implementation for get short answer and get true false. I just hard code in values here for testing. Okay? So I did a little tuple here. My short answer is, who created Python. It's Guido Van Rossam. And then here's another one. Python is a strongly typed language, false.
alright so and so over here in Maine
I start off. And so, initially, I can just work with a mock question, all right, and I can ask it for the true false, and then I can ask it for the short answer, and I can do whatever I want with.
Alright, then I can step it up, and I can say, Well, I don't have a database ready yet, but I can read from a file.
And so this code example gets information. A true false question from a file, and a short answer question from a file. So it reads from the file, and then it returns the question and answer, okay. So, getting closer to the real thing.
alright. And so down here in Maine. Then I plug in a file version
all right. And then finally, the final real version would be, it comes from a sqlite database. And so I have this sqlite question. All of them inherit from that supertype.
And so here I connect to a database. I execute a SQL. Query. All right, and then I return the question and answer. So the underlying code. The fact of the matter is what I have here from lines 14 to 17 could have gone in a function
same thing with 21 and 24. It's all the same code. And then I could have passed in the mock version, the file version and the sqlite version. But I'm doing the same thing. So I go from mock to something close to real, to the real thing.
And so it's just a natural thing to want to do. But you just need to build some infrastructure, a super type, you know, super class, or an abstract base class in python, and then the mock can inherit from it, and then the real thing inherits from it, and then you just plug in whichever one you want
when you're ready. So kind of cool now, also shown in this example. But we're not going to talk about, especially because we're out of time, and I just ran 1 min over the sqlite stuff. So what we will talk about next week, my friends, is
we will do as a code example. And so I activated Module 6. We're going to look at sqlite. I'll talk to you about the basics of SQL structured query language
just a little bit. Okay. We have some remaining things as usual that we didn't get to this week, so we will. Going back to our agenda. I'll just move it to next time.
We'll talk about our solid principles. We'll talk about the agile manifesto and we'll talk about these things called code smells potential problem areas in code. And then the other thing we'll look at is sqlite. We'll look at how to wire it in. I'll walk you through it from scratch. Here's how we do it using Pycharm, and then we'll also talk about pickling, which is, which is a way to save data that's stored in objects in memory to a file
and then load it up again later for those of you done dungeon adventure. You're really going to want to pickle because it's going to let you do your save game load game
potentially, very easily.
So
okay, I know it's always so much and so fast and furious. I'm trying to sneak in so many things. So I do appreciate your guys attention and patience. And of course, thank goodness.
everything I say is recorded. So we are done.
Does anyone have any last questions or clarifications before I turn you loose?
Okay.
I do appreciate you hanging out with me. And so I will send an announcement Tuesday morning. When your quiz is ready. To to let you know. All right. It'll be active from probably like 9 Am. Tuesday, and then you'll have until 1159 Friday. Well, the other thing is, we'll go over the quiz next Saturday in class. We'll go over the results and stuff. We'll talk about the questions and each of those things. And so
and so, yeah, your 1st iteration ends tomorrow and you need to turn in your materials Tuesday, and if you have questions as you gather, that stuff up, if you're hey, Tom, is this good enough? Or whatever. Send me an email, and and I'll let you know. Probably gonna be fine. But
so there you go.
Have yourself a good evening. I'm gonna run right over to my office hour. Zoom link in case you want to drop in. You guys are welcome. You are welcome. And like I said, I appreciate your interaction today. Get yourself some rest and keep plugging away on your project and your Uml, and get ready for that quiz.
We're done. Cheers.
